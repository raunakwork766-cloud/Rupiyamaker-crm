import React, { useState, useEffect, useRef } from 'react';
import axios from 'axios';
import { 
  Camera, 
  CheckCircle, 
  XCircle, 
  MapPin, 
  Clock, 
  AlertTriangle, 
  User,
  Calendar,
  Timer,
  Loader,
  CameraOff,
  RefreshCw
} from 'lucide-react';

const AttendanceCheckInOut = ({ user }) => {
  // State for attendance
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);
  const [success, setSuccess] = useState(null);
  const [attendanceType, setAttendanceType] = useState(null); // 'check-in' or 'check-out'
  const [photoData, setPhotoData] = useState(null);
  const [geolocation, setGeolocation] = useState(null);
  const [attendanceStatus, setAttendanceStatus] = useState(null);
  const [todayAttendance, setTodayAttendance] = useState(null);
  const [attendanceSettings, setAttendanceSettings] = useState(null);
  const [showCamera, setShowCamera] = useState(false);
  const [comments, setComments] = useState('');
  const [currentTime, setCurrentTime] = useState(new Date());
  const [locationPermission, setLocationPermission] = useState(null);
  const [cameraPermission, setCameraPermission] = useState(null);

  // Refs
  const videoRef = useRef(null);
  const canvasRef = useRef(null);
  const streamRef = useRef(null);

  // Update current time every second
  useEffect(() => {
    const timer = setInterval(() => {
      setCurrentTime(new Date());
    }, 1000);

    return () => clearInterval(timer);
  }, []);

  // Get attendance settings and today's attendance on component mount
  useEffect(() => {
    fetchAttendanceSettings();
    fetchTodayAttendance();
    checkPermissions();

    return () => {
      // Clean up video stream when component unmounts
      if (streamRef.current) {
        streamRef.current.getTracks().forEach(track => track.stop());
      }
    };
  }, []);

  const checkPermissions = async () => {
    // Check geolocation permission
    if (navigator.geolocation) {
      try {
        const permission = await navigator.permissions.query({name: 'geolocation'});
        setLocationPermission(permission.state);
      } catch (err) {
        console.warn('Permission API not supported');
        setLocationPermission('granted'); // Assume granted for fallback
      }
    } else {
      setLocationPermission('denied');
    }

    // Check camera permission
    try {
      const permission = await navigator.permissions.query({name: 'camera'});
      setCameraPermission(permission.state);
    } catch (err) {
      console.warn('Permission API not supported');
      setCameraPermission('granted'); // Assume granted for fallback
    }
  };

  const fetchAttendanceSettings = async () => {
    try {
      const response = await axios.get('http://localhost:8048/settings/attendance-settings', {
        headers: {
          Authorization: `Bearer ${localStorage.getItem('token')}`
        }
      });
      
      if (response.data && response.data.success) {
        setAttendanceSettings(response.data.settings);
      }
    } catch (err) {
      console.error("Error fetching attendance settings:", err);
      // Use default settings if API fails
      setAttendanceSettings({
        check_in_time: '10:00',
        check_out_time: '19:00',
        required_working_hours: 8.0,
        late_check_in_threshold: '10:30',
        early_check_out_threshold: '18:30',
        geo_location_required: true,
        photo_required: true,
        working_days: [0, 1, 2, 3, 4, 5], // Monday to Saturday
        half_day_rules: {
          late_check_in: true,
          early_check_out: true,
          insufficient_hours: true
        }
      });
    }
  };

  const fetchTodayAttendance = async () => {
    try {
      const user_id = localStorage.getItem('userId');
      
      const response = await axios.get(`http://localhost:8048/attendance/today?user_id=${user_id}`, {
        headers: {
          Authorization: `Bearer ${localStorage.getItem('token')}`
        }
      });
      
      if (response.data && response.data.success) {
        const data = response.data.data;
        setTodayAttendance(data);
        
        // Determine available actions
        if (data.can_check_in) {
          setAttendanceType('check-in');
        } else if (data.can_check_out) {
          setAttendanceType('check-out');
        } else {
          setAttendanceType(null); // Both check-in and check-out are done
        }
      } else {
        // No attendance record for today
        setAttendanceType('check-in');
      }
    } catch (err) {
      console.error("Error fetching today's attendance:", err);
      setAttendanceType('check-in'); // Default to check-in if error
    }
  };

  const getGeolocation = () => {
    return new Promise((resolve, reject) => {
      if (!navigator.geolocation) {
        reject(new Error('Geolocation is not supported by your browser'));
        return;
      }
      
      const options = {
        enableHighAccuracy: true,
        timeout: 10000,
        maximumAge: 300000 // 5 minutes
      };
      
      navigator.geolocation.getCurrentPosition(
        (position) => {
          resolve({
            latitude: position.coords.latitude,
            longitude: position.coords.longitude,
            accuracy: position.coords.accuracy
          });
        },
        (err) => {
          let errorMessage = 'Failed to get location';
          switch(err.code) {
            case err.PERMISSION_DENIED:
              errorMessage = 'Location access denied. Please enable location permissions.';
              break;
            case err.POSITION_UNAVAILABLE:
              errorMessage = 'Location information unavailable.';
              break;
            case err.TIMEOUT:
              errorMessage = 'Location request timeout.';
              break;
          }
          reject(new Error(errorMessage));
        },
        options
      );
    });
  };

  const startCamera = async () => {
    try {
      setError(null);
      const stream = await navigator.mediaDevices.getUserMedia({
        video: { facingMode: 'user' }
      });
      
      if (videoRef.current) {
        videoRef.current.srcObject = stream;
        streamRef.current = stream;
      }
      
      setShowCamera(true);
    } catch (err) {
      console.error("Error accessing camera:", err);
      setError("Failed to access camera. Please check camera permissions.");
    }
  };

  const capturePhoto = () => {
    if (!videoRef.current || !canvasRef.current) return;
    
    const video = videoRef.current;
    const canvas = canvasRef.current;
    
    canvas.width = video.videoWidth;
    canvas.height = video.videoHeight;
    
    const context = canvas.getContext('2d');
    context.drawImage(video, 0, 0, canvas.width, canvas.height);
    
    const photoData = canvas.toDataURL('image/jpeg');
    setPhotoData(photoData);
    
    // Stop the camera stream
    if (streamRef.current) {
      streamRef.current.getTracks().forEach(track => track.stop());
    }
    
    setShowCamera(false);
  };

  const handleAttendance = async (type) => {
    try {
      setLoading(true);
      setError(null);
      setSuccess(null);

      // Check if photo is required
      if (attendanceSettings?.photo_required && !photoData) {
        setError("Photo is required for attendance. Please capture your photo.");
        setLoading(false);
        return;
      }

      // Get geolocation if required
      let locationData = null;
      if (attendanceSettings?.geo_location_required) {
        try {
          locationData = await getGeolocation();
          setGeolocation(locationData);
        } catch (err) {
          console.error("Error getting geolocation:", err);
          setError("Geolocation is required. Please allow location access.");
          setLoading(false);
          return;
        }
      }

      const user_id = localStorage.getItem('userId');
      const payload = {
        photo_data: photoData,
        geolocation: locationData,
        comments: comments
      };

      const endpoint = type === 'check-in' ? 
        'http://localhost:8048/attendance/check-in' : 
        'http://localhost:8048/attendance/check-out';

      const response = await axios.post(`${endpoint}?user_id=${user_id}`, payload, {
        headers: {
          'Authorization': `Bearer ${localStorage.getItem('token')}`,
          'Content-Type': 'application/json'
        }
      });

      if (response.data && response.data.success) {
        setSuccess(response.data.message);
        setAttendanceStatus(response.data.data);
        
        // Clear form data
        setPhotoData(null);
        setComments('');
        
        // Refresh today's attendance
        await fetchTodayAttendance();
      }
    } catch (err) {
      console.error(`Error during ${type}:`, err);
      setError(err.response?.data?.detail || `Failed to ${type}. Please try again.`);
    } finally {
      setLoading(false);
    }
  };

  const formatTime = (timeString) => {
    if (!timeString) return "-";
    
    try {
      const date = new Date(timeString);
      return date.toLocaleTimeString('en-US', { 
        hour: '2-digit', 
        minute: '2-digit',
        hour12: false 
      });
    } catch (e) {
      return timeString;
    }
  };

  const formatDateTime = (dateTimeString) => {
    if (!dateTimeString) return "-";
    
    try {
      const date = new Date(dateTimeString);
      return date.toLocaleString('en-US', { 
        day: '2-digit',
        month: 'long',
        year: 'numeric',
        hour: '2-digit', 
        minute: '2-digit',
        hour12: false
      });
    } catch (e) {
      return dateTimeString;
    }
  };

  // Calculate working hours
  const calculateWorkingHours = () => {
    if (!todayAttendance?.check_in || !todayAttendance?.check_out) return null;
    
    const checkInTime = new Date(todayAttendance.check_in);
    const checkOutTime = new Date(todayAttendance.check_out);
    const diffMs = checkOutTime - checkInTime;
    const diffHrs = diffMs / (1000 * 60 * 60);
    
    return diffHrs.toFixed(2);
  };

  const workingHours = calculateWorkingHours();

  return (
    <div className="bg-gray-900 p-6 rounded-xl shadow-lg max-w-3xl mx-auto">
      <h2 className="text-2xl font-bold text-blue-400 mb-6 flex items-center">
        <Clock className="mr-2" /> Daily Attendance
      </h2>

      {/* Today's Status Summary */}
      <div className="bg-gray-800 p-4 rounded-lg mb-6">
        <h3 className="text-lg font-semibold text-white mb-3">Today's Status</h3>
        <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
          <div className="bg-gray-700 p-3 rounded-lg">
            <p className="text-sm text-gray-400">Check-In Time</p>
            <p className="text-lg font-bold text-white">
              {todayAttendance?.check_in ? formatTime(todayAttendance.check_in) : "Not checked in"}
            </p>
          </div>
          <div className="bg-gray-700 p-3 rounded-lg">
            <p className="text-sm text-gray-400">Check-Out Time</p>
            <p className="text-lg font-bold text-white">
              {todayAttendance?.check_out ? formatTime(todayAttendance.check_out) : "Not checked out"}
            </p>
          </div>
          <div className={`p-3 rounded-lg ${
            todayAttendance?.status === 'PRESENT' ? 'bg-green-700' :
            todayAttendance?.status === 'HALF_DAY' ? 'bg-yellow-700' :
            todayAttendance?.status === 'ABSENT' ? 'bg-red-700' :
            'bg-gray-700'
          }`}>
            <p className="text-sm text-gray-200">Status</p>
            <p className="text-lg font-bold text-white">
              {todayAttendance?.status || "Not marked"}
            </p>
          </div>
        </div>

        {workingHours && (
          <div className="mt-3 bg-gray-700 p-3 rounded-lg">
            <p className="text-sm text-gray-400">Working Hours</p>
            <p className="text-lg font-bold text-white">{workingHours} hours</p>
          </div>
        )}

        {todayAttendance?.status === 'HALF_DAY' && todayAttendance?.half_day_reason && (
          <div className="mt-3 bg-yellow-800/30 p-3 rounded-lg flex">
            <AlertTriangle className="text-yellow-400 mr-2 flex-shrink-0" />
            <p className="text-yellow-300">
              Half day reason: {todayAttendance.half_day_reason}
            </p>
          </div>
        )}
      </div>

      {/* Camera Section */}
      {showCamera && (
        <div className="mb-6">
          <div className="bg-black rounded-lg overflow-hidden relative">
            <video
              ref={videoRef}
              autoPlay
              playsInline
              className="w-full h-64 object-cover"
            ></video>
            
            <button 
              className="absolute bottom-4 left-1/2 transform -translate-x-1/2 bg-blue-500 hover:bg-blue-600 text-white py-2 px-6 rounded-full shadow-lg flex items-center"
              onClick={capturePhoto}
            >
              <Camera className="mr-2" /> Capture Photo
            </button>
          </div>
          <canvas ref={canvasRef} className="hidden"></canvas>
        </div>
      )}

      {/* Captured Photo */}
      {photoData && (
        <div className="mb-6">
          <h3 className="text-lg font-semibold text-white mb-2">Captured Photo:</h3>
          <div className="bg-gray-800 p-2 rounded-lg">
            <img 
              src={photoData} 
              alt="Captured" 
              className="rounded-lg max-h-64 mx-auto"
            />
            <div className="flex justify-end mt-2">
              <button 
                className="bg-gray-700 hover:bg-gray-600 text-white py-1 px-4 rounded"
                onClick={() => {
                  setPhotoData(null);
                  setShowCamera(false);
                }}
              >
                Retake
              </button>
            </div>
          </div>
        </div>
      )}

      {/* Geolocation Data */}
      {geolocation && (
        <div className="mb-6">
          <h3 className="text-lg font-semibold text-white mb-2">Location Data:</h3>
          <div className="bg-gray-800 p-3 rounded-lg flex items-start">
            <MapPin className="text-blue-400 mr-2 flex-shrink-0 mt-1" />
            <div>
              <p className="text-white">Latitude: {geolocation.latitude.toFixed(6)}</p>
              <p className="text-white">Longitude: {geolocation.longitude.toFixed(6)}</p>
              <p className="text-gray-400 text-sm">Accuracy: ±{geolocation.accuracy.toFixed(1)}m</p>
            </div>
          </div>
        </div>
      )}

      {/* Status Messages */}
      {error && (
        <div className="mb-6 bg-red-900/30 border border-red-700 p-4 rounded-lg flex items-center">
          <XCircle className="text-red-500 mr-2 flex-shrink-0" />
          <p className="text-red-300">{error}</p>
        </div>
      )}

      {success && (
        <div className="mb-6 bg-green-900/30 border border-green-700 p-4 rounded-lg flex items-center">
          <CheckCircle className="text-green-500 mr-2 flex-shrink-0" />
          <p className="text-green-300">{success}</p>
        </div>
      )}

      {/* Action Buttons */}
      <div className="flex flex-wrap gap-4">
        {!photoData && !showCamera && (
          <button
            className="bg-blue-600 hover:bg-blue-700 text-white py-3 px-6 rounded-lg shadow flex items-center"
            onClick={startCamera}
          >
            <Camera className="mr-2" /> Capture Photo
          </button>
        )}

        {attendanceType === 'check-in' && photoData && (
          <button
            className="bg-green-600 hover:bg-green-700 text-white py-3 px-6 rounded-lg shadow flex items-center flex-1"
            onClick={() => handleAttendance('check-in')}
            disabled={loading}
          >
            {loading ? (
              <>
                <span className="animate-spin mr-2">⏳</span> Processing...
              </>
            ) : (
              <>
                <CheckCircle className="mr-2" /> Check In
              </>
            )}
          </button>
        )}

        {attendanceType === 'check-out' && photoData && (
          <button
            className="bg-orange-600 hover:bg-orange-700 text-white py-3 px-6 rounded-lg shadow flex items-center flex-1"
            onClick={() => handleAttendance('check-out')}
            disabled={loading}
          >
            {loading ? (
              <>
                <span className="animate-spin mr-2">⏳</span> Processing...
              </>
            ) : (
              <>
                <Clock className="mr-2" /> Check Out
              </>
            )}
          </button>
        )}

        {attendanceType === null && (
          <div className="bg-gray-700 p-4 rounded-lg w-full text-center">
            <p className="text-white mb-2">You've already completed today's attendance.</p>
            <p className="text-gray-300 text-sm">
              Checked in at {formatDateTime(todayAttendance?.check_in)} and 
              checked out at {formatDateTime(todayAttendance?.check_out)}
            </p>
          </div>
        )}
      </div>
    </div>
  );
};

export default AttendanceCheckInOut;